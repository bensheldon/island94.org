<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Hanami and loading code, faster | Island94.org</title>
  

  <link rel="stylesheet" href="/assets/application-39a1f2f7963cb72fa41194b70f3ff8033d1cbab7fae2f8cb78a801ed41144a6a.css" data-turbo-track="reload" />
  <script type="importmap" data-turbo-track="reload">{
  "imports": {
    "application": "/assets/application-962c5e7cf27f994bdd1d258cdf9ea6b030432b2f7bd4f3ddca08ef99383fa2f8.js",
    "popper": "/assets/popper-003a40d80fd205e1fa00da117d5bdc19720ba330706eaa17f9ba9513fa502304.js",
    "bootstrap": "/assets/bootstrap.min-4ecafa8f279d0b285b3d27ca02c7e5da187907efe2c38f83eb8b4c7d6aa151c4.js",
    "lunr": "/assets/lunr-f99b014c8a6f84586ea3c195936e9cc362e046b318239f33786855679a6b8294.js",
    "@hotwired/turbo-rails": "/assets/turbo.min-3e48f1801baf343469811ff2c47889596fb8b7eb6d8fa63c4d81d0b94dc8c16d.js",
    "@hotwired/stimulus": "/assets/stimulus.min-dd364f16ec9504dfb72672295637a1c8838773b01c0b441bd41008124c407894.js",
    "@hotwired/stimulus-loading": "/assets/stimulus-loading-3576ce92b149ad5d6959438c6f291e2426c86df3b874c525b30faad51b0d96b3.js",
    "controllers/application": "/assets/controllers/application-368d98631bccbf2349e0d4f8269afb3fe9625118341966de054759d96ea86c7e.js",
    "controllers": "/assets/controllers/index-2db729dddcc5b979110e98de4b6720f83f91a123172e87281d5a58410fc43806.js",
    "controllers/search_controller": "/assets/controllers/search_controller-1c839dad802fbbcac7f45100753997dfa82c2453ff1b036badede2d38baef4ff.js",
    "controllers/theme_controller": "/assets/controllers/theme_controller-b01c6e0aeebf1ccac6a41c8358c52557f90e26684cb43214dcef7b5b11213069.js",
    "search": "/assets/search-ddd6c6d0d2f91d8051c02d2b76c8c07937235fba085eb3ff25464fb4db3d8569.js"
  }
}</script>
<link rel="modulepreload" href="/assets/popper-003a40d80fd205e1fa00da117d5bdc19720ba330706eaa17f9ba9513fa502304.js">
<link rel="modulepreload" href="/assets/bootstrap.min-4ecafa8f279d0b285b3d27ca02c7e5da187907efe2c38f83eb8b4c7d6aa151c4.js">
<link rel="modulepreload" href="/assets/turbo.min-3e48f1801baf343469811ff2c47889596fb8b7eb6d8fa63c4d81d0b94dc8c16d.js">
<link rel="modulepreload" href="/assets/stimulus.min-dd364f16ec9504dfb72672295637a1c8838773b01c0b441bd41008124c407894.js">
<link rel="modulepreload" href="/assets/stimulus-loading-3576ce92b149ad5d6959438c6f291e2426c86df3b874c525b30faad51b0d96b3.js">
<script type="module">import "application"</script>

  <script type="text/javascript">
    function setTheme() {
      let theme = localStorage.getItem('theme');
      if (!["light", "dark"].includes(theme)) {
        theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      }
      document.documentElement.setAttribute('data-bs-theme', theme);
    }

    setTheme();
    document.addEventListener('turbo:load', setTheme);
  </script>

  <link rel="alternate" type="application/rss+xml" title="Island94.org" href="https://island94.org/feed.xml">

  
</head>
<body data-controller="search">
  <nav class="navbar navbar-expand-lg navbar-light mb-2 flex-column">
  <div class="container">
    <a class="navbar-brand" href="/">Island94.org</a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
        <li class="nav-item"><a class="nav-link" href="/about">About</a></li>
        <li class="nav-item"><a class="nav-link" href="/archives">Archives</a></li>
        <li class="nav-item"><a class="nav-link" href="/tags">Tags</a></li>
        <li class="nav-item"><a class="nav-link" href="/feed.xml">RSS Feed <i class="bi bi-rss-fill"></i></a></li>

        <li class="nav-item py-2 py-lg-1 col-12 col-lg-auto">
          <div class="vr d-none d-lg-flex h-100 mx-lg-2 text-light-500"></div>
          <hr class="d-lg-none my-0 text-light-500">
        </li>

        <li class="nav-item dropdown" data-controller="theme">
          <button
            data-theme-target="switcher"
            class="btn btn-link nav-link dropdown-toggle"
            type="button"
            aria-expanded="false"
            data-bs-toggle="dropdown">
            <i data-theme-target="activeIcon" class="bi bi-circle-half"></i>
            <span data-theme-target="switcherText">Theme</span>
          </button>
          <ul class="dropdown-menu dropdown-menu-end">
            <li>
              <button
                type="button"
                class="dropdown-item"
                data-bs-theme-value="light"
                data-action="theme#switch"
                aria-pressed="false">
                <i class="bi bi-sun"></i> Light
              </button>
            </li>
            <li>
              <button
                type="button"
                class="dropdown-item"
                data-bs-theme-value="dark"
                data-action="theme#switch"
                aria-pressed="false">
                <i class="bi bi-moon-stars-fill"></i> Dark
              </button>
            </li>
            <li>
              <button
                type="button"
                class="dropdown-item"
                data-bs-theme-value="auto"
                data-action="theme#switch"
                aria-pressed="true">
                <i class="bi bi-circle-half"></i> Auto
              </button>
            </li>
          </ul>
        </li>

      </ul>

      <form id="search" class="d-flex" action="/search" method="get">
        <div class="input-group">
          <input data-search-target="input" data-action="input->search#syncInputs" id="search-box" class="form-control search" role="search" name="q" placeholder="Search" aria-label="Search" results="0" type="text" autocomplete="off">
          <button type="submit" class="btn btn-outline-secondary">
            <i class="bi bi-search"></i>
            <span class="visually-hidden">Search</span>
          </button>
        </div>
      </form>
    </div>
  </div>
  <div class="container">
    <div class="text-muted fst-italic">
      ‚Äî Ben Sheldon's personal blog and <a href="/2012/04/a-commonplace-book">commonplace book</a>.
    </div>
  </div>
</nav>

  
  <div class="container container-body">
    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">
      <a class="post-link" href="/2025/10/hanami-and-loading-code-faster"><p>Hanami and loading code, faster</p>
</a>
    </h1>
    <p class="post-meta text-muted">
        <time datetime="2025-10-08T00:00:00Z" itemprop="datePublished">October 8, 2025</time>

        ‚Ä¢ Tagged <a href="/posts/tags/ruby-on-rails">Ruby on Rails</a> and <a href="/posts/tags/hanami">Hanami</a>
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>I‚Äôll be giving a talk in November in at SF Ruby Conference (<a href="https://luma.com/sfrubyconf2025?coupon=SEP29OCT6">tickets on sale now!</a>). My talk is speeding up your application‚Äôs development cycle by taking a critical eye at your application‚Äôs development boot. Which all boils down to <em>do less</em>. In Ruby, the easiest, though not the simplest, is to load less code. So yeah, autoloading.</p>

<p>To expand my horizons and hopefully give a better talk, I branched out beyond my experience with Ruby on Rails to talk to Tim Riley about Hanami and how it handles code loading during development.</p>

<p>The following are my notes; it‚Äôs not a critical review of Hanami, and it only looks into a very narrow topic: code loading and development performance.</p>

<h3 id="ruby-and-analogously-rails">Ruby, and analogously Rails</h3>

<p>Ruby has a global namespace; constants (classes, modules, CONSTANTS) are global singletons. When your code (or some code you‚Äôre loading‚ÄîRuby calls each file it loads a ‚Äúfeature‚Äù identified by its filesystem path) defines a constant, Ruby is evaluating everything about the constant: the class body, class attributes, basically anything that isn‚Äôt in a block or a method definition. And so any constants that are referenced in the code also need to be loaded and evaluated, and class ancestors, and their code and so forth. That‚Äôs the main reason booting an application is slow: doing stuff just to load the code that defines all the constants so the program can run.</p>

<p>The name of the game in development, where you want to run a single test or browser a single route or open the CLI, is <em>load less</em>. If you can just avoid loading the constant, you can avoid loading the file the constant is defined in, and avoid loading all of its other dependencies and references until <em>later</em>, when you really need them (or never, in development).</p>

<p>The most common strategy for deferring stuff is: use a string as a stand-in for the constant, and only later, when you really need to convert the string to a constant, do it. An example is in Rails Routes, where you‚Äôll write <code>to: ‚Äúmycontroller#index‚Äù</code> and not <code>MyController</code>. At some point the <code>mycontroller</code> gets constantized to <code>MyController</code>, but that‚Äôs <em>later</em>, when you hit that particular route. Another example is Active Record Relation definitions, where you‚Äôll use <code>class_name: ‚ÄúMyModel"</code> instead of <code>class_name: MyModel</code>, which only gets constantized when you use <code>record.my_models</code>.</p>

<p>In Rails, a lot of performance repair work for development is identifying places where a constant <em>shouldn‚Äôt</em> be directly referenced and instead should use some other stand-in until it‚Äôs really needed. In Rails, it can be confusing, because sometimes you can use a configuration string to refer to a constant, and sometimes you have to use a constant; it is inconsistent.</p>

<h3 id="in-hanami-nearly-everything-has-a-string-key">In Hanami, (nearly) everything has a string key</h3>

<p>Hanami‚Äôs approach: make <em>all</em> the application components referencable by a string, called a <code>key</code>. (again, Hanami does quite a bit more than that, I just mean in regards to code loading). Objects are configured by what keys they have dependencies upon, and those objects are <a href="https://guides.hanamirb.org/v2.2/app/container-and-components/#injecting-dependencies-via-deps">injected by the framework</a>. So instead of writing this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span>
  <span class="n">cattr_accessor</span> <span class="ss">:api_client</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">api_client</span> <span class="o">=</span> <span class="no">ApiClient</span><span class="p">.</span><span class="nf">new</span> <span class="c1"># &lt;-- loads that constants</span>

  <span class="k">def</span> <span class="nf">transmit_something</span>
    <span class="no">MyClass</span><span class="p">.</span><span class="nf">api_client</span><span class="p">.</span><span class="nf">transmit</span><span class="p">(</span><span class="s2">"something"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>‚Ä¶you would instead use Hanami‚Äôs <code>Deps</code> and write:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span>
  <span class="kp">include</span> <span class="no">Deps</span><span class="p">[</span><span class="s2">"api_client"</span><span class="p">]</span> <span class="c1"># &lt;-- injects the object</span>

  <span class="k">def</span> <span class="nf">transmit_something</span>
    <span class="n">api_client</span><span class="p">.</span><span class="nf">transmit</span><span class="p">(</span><span class="s2">"something"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Keys are global, and keys whose objects have been loaded live in  <code>Hanami.app.keys</code> . If the key‚Äôs object hasn‚Äôt been loaded yet, it will be converted from a string to‚Ä¶ whatever (not just constants)‚Ä¶ when it‚Äôs needed to execute. Individual objects can be accessed with <code>Hanami.app["thekey"]</code> when debugging, but normal code should get them injected from Deps. By convention, keys match a class name but they don‚Äôt have to. This is <a href="https://dry-rb.org/gems/dry-system/">powered by <code>dry-system</code></a>.</p>

<p>Not <em>everything</em> has to have a key. Functional components in Hanami have a key, but classes that embody a bit of data (in Hanami these are called Structs) do not have entries in the app container, and therefore don‚Äôt have keys.</p>

<p>If you have something functional coming from outside Hanami, like that <code>ApiClient</code> in the code above or coming from a non-Hanami specific gem or wherever, then you can give them a key and define their lifecycle within the application <a href="https://guides.hanamirb.org/v2.2/app/providers/">via a Provider</a>.</p>

<p><strong>Briefly, commentary:</strong> Some common Rails development discourse is ‚ÄúRails is too magic‚Äù, which is leveled because Rails framework can work out what constants you mean without directly referencing them (e.g. <code>has_many :comments</code> implies there‚Äôs an Active Record <code>Comment</code>), and ‚Äújust use a PORO‚Äù (plain old ruby object) when a developer is trying to painfully jam <em>everything</em> into narrow Rails framework primitives. With Hanami:</p>
<ul>
  <li>Hanami has quite a bit of like ‚Äúhere‚Äôs a string, now it‚Äôs an object ü™Ñ‚Äù , but it is consistently applied everywhere and has some nice benefits beyond just brevity, like overloading dependencies.</li>
  <li>Everything does sorta have to be fit into the framework, but there‚Äôs an explicit interface for doing so.</li>
</ul>

<h2 id="assorted-notes-in-this-general-theme">Assorted notes in this general theme</h2>

<ul>
  <li>Providers are like ‚ÄúRails initializers but with more juice‚Äù ‚Äì they register components in the container. They have lifecycle hooks (prepare, start, stop) for managing resources. They‚Äôre lazily loaded and can have namespace capabilities for organizing related components.</li>
  <li>Hanami encourages namespacing over Rails‚Äô flat structure. ‚ÄúSlices‚Äù provide first-class support for modularizing applications like Rails Engines. Each slice has its own container and can have its own providers, creating bounded contexts.</li>
  <li>Hanami uses Zeitwerk for code loading.</li>
  <li>Dev server uses Guard to restart puma in development. Because everything is so modularized, it‚Äôs good enough.</li>
  <li>Code is lazy-loaded in development but fully pre-loaded in production.</li>
</ul>

<h2 id="where-things-are-going">Where things are going</h2>

<p>In the Hanami Discord, Tim shared a proposal for building out a plugin system for Hanami‚Ä¶ and to me looks a lot like Railties and <a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/LazyLoadHooks.html">ActiveSupport lazy load hooks</a>:</p>

<blockquote>
  <p>Using your grant, I propose to implement this Hanami extensions API. The end<br />
goal will be to:</p>

  <ul>
    <li>Allow all first-party ‚Äúframework extension code‚Äù to move from the core Hanami<br />
gem back into the respective Hanami subsystem gems (e.g. the core Hanami<br />
gem should no longer have specific extension logic for views).</li>
    <li>Allow third-party gems to integrate with Hanami on an equal footing to the first-<br />
party gems.</li>
  </ul>

  <p>This will require building at least some of the following:</p>

  <ul>
    <li>Ability for extensions to be detected by or registered with the Hanami framework.</li>
    <li>Ability to enhance or replace Hanami CLI commands.</li>
    <li>Ability to register new configuration settings on the Hanami app.</li>
    <li>Hooks for extending core Hanami classes.</li>
    <li>Hooks for adding logic to Hanami‚Äôs app boot process.</li>
    <li>Adjustments to first-party Hanami gems to allow their classes to be used in an un-extended state when required.</li>
    <li>A separate ‚Äúextension‚Äù gem that can allow Hanami extensions to register their extensions without depending on the main Hanami gem.</li>
  </ul>
</blockquote>

<h3 id="and-how-this-all-started">And how this all started</h3>

<p>Ending on what I originally shared with Tim to start our discussion, which I share partly cause I think it‚Äôs funny how easily I can type out 500 words today on a thesis of like ‚Äúwhy code loading in Ruby is hard‚Äù:</p>

<blockquote>
  <p><strong>Making boot fast; don‚Äôt load the code unless you need it</strong></p>

  <p>Don‚Äôt load code until/unless you need it. DEFINITELY don‚Äôt create database connections or make any http calls or invoke other services. How Rails does it, Rails autoloads as much as possible (framework, plugin/extension, and application code), either via Ruby Autoload or Zeitwerk. The architecture challenge is: how do you set up configuration properties, so that <em>when</em> the code is loaded (and all the different pieces of framework/plugin/extension/application get their fingers on it), it is configured with the properties y‚Äôall ultimately want on it? There are two mechanisms:</p>

  <ul>
    <li>A configuration hash, that is intended to be made up (somewhat) of primitives that are dependency free and thus don‚Äôt load a bunch of code themselves,</li>
    <li>
      <p>A callback hook that is placed within autoloaded code, that one can register against and use it to pull data out of configuration (framework/plugin/extension) or override/overload behavior (your application), that is only triggered when the code is loaded for reals. Extensions put this in a Railtie, maybe you put it in an initializer.,<br />
 The practical problems are:</p>
    </li>
    <li>Ideally everything was stateless and just pulled values from configuration and got torn down after every request/transaction/task, but also:
      <ul>
        <li>Some objects are long-lived, and you don‚Äôt want to constantly be tearing them down,</li>
        <li>Sometimes locality of properties is nice and it would be annoying to be like ‚Äúeither use this locally assigned value OR use this value from really far away in this super deep config object‚Äù.,</li>
        <li>Hopefully that config object is thread and fiber safe if you‚Äôre gonna be changing it later and you‚Äôre not really sure what‚Äôs happening right then in your application lifecycle.,</li>
      </ul>
    </li>
    <li>A hook doesn‚Äôt exist in the place that you want to hook into, so you either have to:
      <ul>
        <li>go upstream and get a hook added; which is annoying (just hook every class and feature, why not?!),</li>
        <li>load the code prematurely so you can directly modify it,</li>
      </ul>
    </li>
    <li>When something else (framework/plugin/extension/application) prematurely loads the code (chaotically or intentionally), before you add your own configuration or before you register a hook callback, and the behavior is stateful or had to be backed out (example: it‚Äôs configuration for connections in a connection pool and early invocation fills the pool with connection objects with premature configuration. So to re-configure you have to drain the pool of the old prematurely configured connections and maybe that‚Äôs hard),</li>
    <li>Examples of pain:
      <ul>
        <li>Devise.
          <ul>
            <li>It‚Äôs route (devise_for) loads your active record model, when routes load, which in &lt; Rails 8.0 was when your app boots, which is premature otherwise,</li>
            <li>Changing the layout of devise controllers. They don‚Äôt have load hooks (maybe they should?). You can subclass them and manually mount them in your app, but htat‚Äôs annoying,</li>
          </ul>
        </li>
        <li>Every initializer where you try to assign config and maybe it won‚Äôt work cause something else already hooked it and loaded it and it‚Äôs baked.,</li>
      </ul>
    </li>
  </ul>

  <p><strong>How Hanami does it:</strong></p>

  <blockquote>
    <p>@inouire in the Rails Discord shared a couple of links: You can find some information about Hanami way of handling dependency container: <a href="https://guides.hanamirb.org/v2.2/app/container-and-components/">https://guides.hanamirb.org/v2.2/app/container-and-components/</a> Also autoloading: <a href="https://guides.hanamirb.org/v2.2/app/autoloading/">https://guides.hanamirb.org/v2.2/app/autoloading/</a> And info about lazy boot: <a href="https://guides.hanamirb.org/v2.2/app/booting/">https://guides.hanamirb.org/v2.2/app/booting/</a></p>
  </blockquote>

  <p>Hanami questions from Ben:</p>
  <ul>
    <li>Components are singletons that are pure-ish functions? Do they get torn down / recreated on every request, or does the same object exist for the lifetime of the application?,</li>
    <li>Is there a pattern of assigning properties to class variables? Seems like most stuff is pure-ish functions. How do you handle objects that you want to be long-lived, like Twitter::Client.new or something?,</li>
    <li>I didn‚Äôt see plugins/extensions. Are you required to subclass and overload a component or can you poke around in an existing class/component? Can I defer poking around in a component until it‚Äôs loaded? (like an autoload hook),</li>
    <li>Are there any patterns you see people do, that would slow down their hanami app‚Äôs boot, that you wish they didn‚Äôt do?</li>
  </ul>
</blockquote>

  </div>
</article>


<div class="card my-4">
  <div class="card-body">
    Discuss this with me on
      <a href="https://ruby.social/@bensheldon"><i class="bi bi-mastodon" style="margin-right: 0.2em"></i>Mastodon</a>,
      <a href="https://bensheldon.bsky.social"><i class="bi bi-bluesky" style="margin-right: 0.2em"></i>Bluesky</a>,
      or suggest a change on
      <a href="https://github.com/bensheldon/island94.org/blob/main/_posts/2025-10-08-hanami-and-loading-code-faster.md" style="text-wrap: nowrap"><i class="bi bi-github" style="margin-right: 0.2em"></i>GitHub</a>.
  </div>
    <hr>
    <div class="card-body">
      <h5>Related Posts</h5>
      <ul>
          <li><a href="/2025/10/serializing-viewcomponent-for-active-job-and-turbo-broadcast-later">Serializing ViewComponent for Active Job and Turbo Broadcast Later</a></li>
          <li><a href="/2025/10/notes-from-building-a-who-is-doing-what-right-now-on-our-website-presence-feature-with-action-cable">Notes from building a ‚Äúwho is doing what right now on our website?‚Äù presence feature with Action Cable</a></li>
          <li><a href="/2025/08/building-deterministic-reproducible-assets-with-sprockets">Building deterministic, reproducible assets with Sprockets</a></li>
          <li><a href="/2025/08/everything-i-know-about-ai-learned-by-reading-the-aws-bedrock-client-ruby-sdk-code">Everything I know about AI, I learned by reading the AWS Bedrock Client Ruby SDK code</a></li>
          <li><a href="/2023/08/how-to-isolate-i18n-configuration-in-a-rails-engine">How to isolate I18n configuration in a Rails Engine</a></li>
      </ul>
  </div>
</div>

  </div>

</body>
</html>
