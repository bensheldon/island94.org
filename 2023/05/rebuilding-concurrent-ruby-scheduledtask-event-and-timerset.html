<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Rebuilding Concurrent Ruby: ScheduledTask, Event, and TimerSet | Island94.org</title>

  <meta name="csrf-param" content="authenticity_token" />
<meta name="csrf-token" content="IcB4nma03jf9gKe87rTSdNOt6R1UapjHy5sLNDXdRlZKz_mnclqfIyLCzBKjxBqA63CY9moYfiRMpQkn6_6ihg" />
  

  <link rel="alternate" type="application/rss+xml" title="Island94.org" href="https://island94.org/feed.xml">

  <link rel="stylesheet" href="/assets/application-2d0874f724227ac5e099df0bd7cfeb3a4fc86f9358ede0d8216b193fa7a7da99.css" data-turbo-track="reload" />
  <script type="importmap" data-turbo-track="reload">{
  "imports": {
    "application": "/assets/application-962c5e7cf27f994bdd1d258cdf9ea6b030432b2f7bd4f3ddca08ef99383fa2f8.js",
    "popper": "/assets/popper-003a40d80fd205e1fa00da117d5bdc19720ba330706eaa17f9ba9513fa502304.js",
    "bootstrap": "/assets/bootstrap.min-3389e8d94238c6aae57b91819279862a918c12e4596fd5a397c51f16df96057e.js",
    "lunr": "/assets/lunr-f99b014c8a6f84586ea3c195936e9cc362e046b318239f33786855679a6b8294.js",
    "@hotwired/turbo-rails": "/assets/turbo.min-4cfe7c6aaeb9120821760aa53763dff54fbc561e500da6482fc43c54c7384929.js",
    "@hotwired/stimulus": "/assets/stimulus.min-dd364f16ec9504dfb72672295637a1c8838773b01c0b441bd41008124c407894.js",
    "@hotwired/stimulus-loading": "/assets/stimulus-loading-3576ce92b149ad5d6959438c6f291e2426c86df3b874c525b30faad51b0d96b3.js",
    "controllers/application": "/assets/controllers/application-368d98631bccbf2349e0d4f8269afb3fe9625118341966de054759d96ea86c7e.js",
    "controllers": "/assets/controllers/index-2db729dddcc5b979110e98de4b6720f83f91a123172e87281d5a58410fc43806.js",
    "controllers/search_controller": "/assets/controllers/search_controller-1c839dad802fbbcac7f45100753997dfa82c2453ff1b036badede2d38baef4ff.js",
    "controllers/theme_controller": "/assets/controllers/theme_controller-b01c6e0aeebf1ccac6a41c8358c52557f90e26684cb43214dcef7b5b11213069.js",
    "search": "/assets/search-ddd6c6d0d2f91d8051c02d2b76c8c07937235fba085eb3ff25464fb4db3d8569.js"
  }
}</script>
<link rel="modulepreload" href="/assets/popper-003a40d80fd205e1fa00da117d5bdc19720ba330706eaa17f9ba9513fa502304.js">
<link rel="modulepreload" href="/assets/bootstrap.min-3389e8d94238c6aae57b91819279862a918c12e4596fd5a397c51f16df96057e.js">
<link rel="modulepreload" href="/assets/turbo.min-4cfe7c6aaeb9120821760aa53763dff54fbc561e500da6482fc43c54c7384929.js">
<link rel="modulepreload" href="/assets/stimulus.min-dd364f16ec9504dfb72672295637a1c8838773b01c0b441bd41008124c407894.js">
<link rel="modulepreload" href="/assets/stimulus-loading-3576ce92b149ad5d6959438c6f291e2426c86df3b874c525b30faad51b0d96b3.js">
<script type="module">import "application"</script>

  <script>
    function setTheme() {
      let theme = localStorage.getItem('theme');
      if (!["light", "dark"].includes(theme)) {
        theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      }
      document.documentElement.setAttribute('data-bs-theme', theme);
    }

    setTheme();
    document.addEventListener('turbo:load', setTheme);
  </script>

  
</head>
<body data-controller="search">
  <nav class="navbar navbar-expand-lg navbar-light mb-2 flex-column">
  <div class="container">
    <a class="navbar-brand" href="/">Island94.org</a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
        <li class="nav-item"><a class="nav-link" href="/about">About</a></li>
        <li class="nav-item"><a class="nav-link" href="/archives">Archives</a></li>
        <li class="nav-item"><a class="nav-link" href="/tags">Tags</a></li>
        <li class="nav-item"><a class="nav-link" href="/feed.xml">RSS Feed <i class="bi bi-rss-fill"></i></a></li>

        <li class="nav-item py-2 py-lg-1 col-12 col-lg-auto">
          <div class="vr d-none d-lg-flex h-100 mx-lg-2 text-light-500"></div>
          <hr class="d-lg-none my-0 text-light-500">
        </li>

        <li class="nav-item dropdown" data-controller="theme">
          <button
            data-theme-target="switcher"
            class="btn btn-link nav-link dropdown-toggle"
            type="button"
            aria-expanded="false"
            data-bs-toggle="dropdown"
          >
            <i data-theme-target="activeIcon" class="bi bi-circle-half"></i>
            <span data-theme-target="switcherText">Theme</span>
          </button>
          <ul class="dropdown-menu dropdown-menu-end">
            <li>
              <button
                type="button"
                class="dropdown-item"
                data-bs-theme-value="light"
                data-action="theme#switch"
                aria-pressed="false"
              >
                <i class="bi bi-sun"></i> Light
              </button>
            </li>
            <li>
              <button
                type="button"
                class="dropdown-item"
                data-bs-theme-value="dark"
                data-action="theme#switch"
                aria-pressed="false"
              >
                <i class="bi bi-moon-stars-fill"></i> Dark
              </button>
            </li>
            <li>
              <button
                type="button"
                class="dropdown-item"
                data-bs-theme-value="auto"
                data-action="theme#switch"
                aria-pressed="true"
              >
                <i class="bi bi-circle-half"></i> Auto
              </button>
            </li>
          </ul>
        </li>

      </ul>

      <form id="search" class="d-flex" action="/search" method="get">
        <div class="input-group">
          <input data-search-target="input" data-action="input->search#syncInputs" id="search-box" class="form-control search" role="search" name="q" placeholder="Search" aria-label="Search" results="0" type="text">
          <button type="submit" class="btn btn-outline-secondary">
            <i class="bi bi-search"></i>
            <span class="visually-hidden">Search</span>
          </button>
        </div>
      </form>
    </div>
  </div>
  <div class="container">
    <div class="text-muted fst-italic">
      ‚Äî Ben Sheldon's personal blog and <a href="/2012/04/a-commonplace-book">commonplace book</a>.
    </div>
  </div>
</nav>

  
  <div class="container container-body">
    
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">
      <a class="post-link" href="/2023/05/rebuilding-concurrent-ruby-scheduledtask-event-and-timerset"><p>Rebuilding Concurrent Ruby: ScheduledTask, Event, and TimerSet</p>
</a>
    </h1>
    <p class="post-meta text-muted">
        <time datetime="2023-05-31T18:44:00-07:00" itemprop="datePublished">May 31, 2023</time>

        ‚Ä¢ Tagged <a href="/posts/tags/ruby">ruby</a> and <a href="/posts/tags/goodjob">GoodJob</a>
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>I‚Äôve been diving into <a href="https://github.com/ruby-concurrency/concurrent-ruby">Concurrent Ruby library</a> a lot recently. I use Concurrent Ruby as the foundation for <a href="https://github.com/bensheldon/good_job">GoodJob</a> where it has saved me immense time and grief because it has a lot of reliable, complex thread-safe primitives that are well-shaped for GoodJob‚Äôs needs. I‚Äôm a big fan of Concurrent Ruby.</p>

<p>I wanted to cement some of my learnings and understandings by writing a quick blog post to explain how some parts of Concurrent Ruby work, in the spirit of Noah Gibb‚Äôs <a href="https://rebuilding-rails.com/"><em>Rebuilding Rails</em></a>. In the following, I‚Äôll be sharing runnable Ruby code that is similar to how Concurrent Ruby solves the same kind of problems. That said, <strong>Concurrent Ruby is much, much safer‚Äîand thus a little more complex‚Äîthan what I‚Äôm writing here</strong> so please, if you need this functionality, use Concurrent Ruby directly.</p>

<h3 id="the-use-case-future-scheduled-tasks">The use case: future scheduled tasks</h3>

<p>Imagine you want to run some bits of code, at a point in time in the future. It might look like this example creating several tasks at once with varying delays in seconds:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ScheduledTask</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">delay</span> <span class="o">=</span> <span class="mi">30</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># run some code</span>
<span class="k">end</span>

<span class="no">ScheduledTask</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># run some code</span>
<span class="k">end</span>

<span class="no">ScheduledTask</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># run some code</span>
<span class="k">end</span>
</code></pre></div></div>

<p>In Concurrent Ruby, the object to do this is a <a href="https://ruby-concurrency.github.io/concurrent-ruby/1.2.0/Concurrent/ScheduledTask.html"><code>Concurrent::ScheduledTask</code></a> (good name, right?). A ScheduledTask will wait <code>delay</code> seconds and then run the block of code on a background thread.</p>

<p>Behind the ScheduledTask is the real star: the <a href="https://ruby-concurrency.github.io/concurrent-ruby/1.2.0/Concurrent/TimerSet.html"><code>Concurrent::TimerSet</code></a>, which executes a collection of tasks, each after a given delay. Let‚Äôs break down the components of a TimerSet:</p>

<ul>
  <li>TimerSet maintains a list of tasks, ordered by their delays, with the soonest first</li>
  <li>TimerSet runs a reactor-like loop in a background thread. This thread will peek at the next occurring task and wait/sleep until it occurs, then pop the task to execute it.</li>
  <li>TimerSet uses a <code>Concurrent::Event</code> (which is like a <code>Mutex</code> and <code>ConditionVariable</code> combined in a convenient package) to interrupt the sleeping reactor when new tasks are created.</li>
</ul>

<p>I‚Äôll give examples of each of these. But first, you may be asking‚Ä¶.</p>

<h2 id="why-is-this-so-hard">Why is this so hard?</h2>

<p>This is a lot of objects working together to accomplish the use case. This is why:</p>

<ul>
  <li>Ruby threads have a cost, so we can‚Äôt simply create a new thread for each and every task, putting it to sleep until an individual task is intended to be triggered. That would be a lot of threads.</li>
  <li>Ruby threads <a href="http://headius.blogspot.com/2008/02/rubys-threadraise-threadkill-timeoutrb.html">aren‚Äôt safe be canceled/killed</a>, so we can‚Äôt, for example, create a single thread for the soonest task but then terminate it and create a new thread if new task is created with a sooner time.</li>
</ul>

<p>The following section will show how these objects are put together. Again, this is not the exact Concurrent Ruby implementation, but it‚Äôs the general shape of how Concurrent Ruby solves this use case.</p>

<h2 id="the-event">The <code>Event</code></h2>

<p>Concurrent Ruby describes a <a href="https://github.com/ruby-concurrency/concurrent-ruby/blob/9f40827be9a8a192a6993a8d157bd3ed0662ada0/lib/concurrent-ruby/concurrent/atomic/event.rb"><code>Concurrent::Event</code></a> as:</p>

<blockquote>
  <p>Old school kernel-style event reminiscent of Win32 programming in C++.</p>
</blockquote>

<p>I don‚Äôt know what that means exactly, but an Event can be in either a set or unset state, and it can wait (with a timeout!) and be awakened via signals across threads.</p>

<p>I earlier described <code>Event</code> as a <code>Mutex</code> and <code>ConditionVariable</code> packaged together. The <code>ConditionVariable</code>is the star here, and the mutex is simply a supporting actor because the ConditionVariable requires it.</p>

<p>A <a href="https://docs.ruby-lang.org/en/3.2/Thread/ConditionVariable.html">Ruby <code>ConditionVariable</code></a> has two features that are perfect for multithreaded programming:</p>

<ul>
  <li><code>wait</code>, which is blocking and will put a thread to sleep, with an optional timeout</li>
  <li><code>set</code>, which broadcasts a signal to any waiting threads to wake up.</li>
</ul>

<p>Jesse Storimer‚Äôs excellent and free ebook <em>Working with Ruby Threads</em> has a great <a href="https://workingwithruby.com/wwrt/condvars/">section on ConditionVariables</a> and why the mutex is a necessary part of the implementation.</p>

<p>Here‚Äôs some code that implements an Event with an example to show how it can wake up a thread:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Event</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@mutex</span> <span class="o">=</span> <span class="no">Mutex</span><span class="p">.</span><span class="nf">new</span>
    <span class="vi">@condition</span> <span class="o">=</span> <span class="no">ConditionVariable</span><span class="p">.</span><span class="nf">new</span>
    <span class="vi">@set</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
    <span class="vi">@mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
      <span class="vi">@set</span> <span class="o">||</span> <span class="vi">@condition</span><span class="p">.</span><span class="nf">wait</span><span class="p">(</span><span class="vi">@mutex</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">set</span>
    <span class="vi">@mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
      <span class="vi">@set</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="vi">@condition</span><span class="p">.</span><span class="nf">broadcast</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">reset</span>
    <span class="vi">@mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
      <span class="vi">@set</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Here‚Äôs a simple example of an Event running in a loop to show how it might be used:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">event</span> <span class="o">=</span> <span class="no">Event</span><span class="p">.</span><span class="nf">new</span>
<span class="n">running</span> <span class="o">=</span> <span class="kp">true</span>
<span class="n">thread</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="c1"># A simple loop in a thread</span>
  <span class="k">while</span> <span class="n">running</span> <span class="k">do</span>
    <span class="c1"># loop every second unless signaled</span>
    <span class="k">if</span> <span class="n">event</span><span class="p">.</span><span class="nf">wait</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="nb">puts</span> <span class="s2">"Event has been set"</span>
      <span class="n">event</span><span class="p">.</span><span class="nf">reset</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="nb">puts</span> <span class="s2">"Exiting thread"</span>
<span class="k">end</span>

<span class="nb">sleep</span> <span class="mi">1</span>
<span class="n">event</span><span class="p">.</span><span class="nf">set</span>
<span class="c1">#=&gt; Event has been set</span>

<span class="nb">sleep</span> <span class="mi">1</span>
<span class="n">event</span><span class="p">.</span><span class="nf">set</span>
<span class="c1">#=&gt; Event has been set</span>

<span class="c1"># let the thread exit</span>
<span class="n">running</span> <span class="o">=</span> <span class="kp">false</span>
<span class="n">thread</span><span class="p">.</span><span class="nf">join</span>
<span class="c1">#=&gt; Exiting thread</span>

</code></pre></div></div>

<h3 id="the-scheduledtask">The <code>ScheduledTask</code></h3>

<p>The implementation of the ScheduledTask isn‚Äôt too important in this explanation, but I‚Äôll sketch out the necessary pieces, which match up with a <a href="https://github.com/ruby-concurrency/concurrent-ruby/blob/9f40827be9a8a192a6993a8d157bd3ed0662ada0/lib/concurrent-ruby/concurrent/scheduled_task.rb"><code>Concurrent::ScheduledTask</code></a>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># GLOBAL_TIMER_SET = TimerSet.new</span>

<span class="k">class</span> <span class="nc">ScheduledTask</span>
  <span class="nb">attr_reader</span> <span class="ss">:schedule_time</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="ss">timer_set: </span><span class="no">GLOBAL_TIMER_SET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task</span><span class="p">)</span>
    <span class="n">scheduled_task</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task</span><span class="p">)</span>
    <span class="n">timer_set</span><span class="p">.</span><span class="nf">post_task</span><span class="p">(</span><span class="n">scheduled_task</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task</span><span class="p">)</span>
    <span class="vi">@schedule_time</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">+</span> <span class="n">delay</span>
    <span class="vi">@task</span> <span class="o">=</span> <span class="n">task</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">run</span>
    <span class="vi">@task</span><span class="p">.</span><span class="nf">call</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">&lt;</span><span class="o">=&gt;</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
    <span class="n">schedule_time</span> <span class="o">&lt;=&gt;</span> <span class="n">other</span><span class="p">.</span><span class="nf">schedule_time</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>A couple things to call out here:</p>

<ul>
  <li>The  <code>GLOBAL_TIMER_SET</code> is necessary so that all ScheduledTasks are added to the same TimerSet. In Concurrent Ruby, this is <code>Concurrent.global_timer_set</code>, though a <code>ScheduledTask.execute</code> can be given an explicit <code>timer_set:</code> parameter if an application has multiple TimerSets (for example, GoodJob initializes its own TimerSet for finer lifecycle management).</li>
  <li>The <code>&lt;=&gt;</code> comparison operator, which will be used to keep our list of tasks sorted with the soonest tasks first.</li>
</ul>

<h3 id="the-timerset">The <code>TimerSet</code></h3>

<p>Now we have the pieces necessary to implement a TimerSet and fulfill our use case. The TimerSet implemented here is very similar to a <a href="https://github.com/ruby-concurrency/concurrent-ruby/blob/9f40827be9a8a192a6993a8d157bd3ed0662ada0/lib/concurrent-ruby/concurrent/executor/timer_set.rb"><code>Concurrent::TimerSet</code></a>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TimerSet</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@queue</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="vi">@mutex</span> <span class="o">=</span> <span class="no">Mutex</span><span class="p">.</span><span class="nf">new</span>
    <span class="vi">@event</span> <span class="o">=</span> <span class="no">Event</span><span class="p">.</span><span class="nf">new</span>
    <span class="vi">@thread</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">post_task</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
    <span class="vi">@mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
      <span class="vi">@queue</span> <span class="o">&lt;&lt;</span> <span class="n">task</span>
      <span class="vi">@queue</span><span class="p">.</span><span class="nf">sort!</span>
      <span class="n">process_tasks</span> <span class="k">if</span> <span class="vi">@queue</span><span class="p">.</span><span class="nf">size</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">end</span>
    <span class="vi">@event</span><span class="p">.</span><span class="nf">set</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">shutdown</span>
    <span class="vi">@mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="p">{</span> <span class="vi">@queue</span><span class="p">.</span><span class="nf">clear</span> <span class="p">}</span>
    <span class="vi">@event</span><span class="p">.</span><span class="nf">set</span>
    <span class="vi">@thread</span><span class="p">.</span><span class="nf">join</span> <span class="k">if</span> <span class="vi">@thread</span>
    <span class="kp">true</span>
  <span class="k">end</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">process_tasks</span>
    <span class="vi">@thread</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
      <span class="kp">loop</span> <span class="k">do</span>
        <span class="c1"># Peek the first item in the queue</span>
        <span class="n">task</span> <span class="o">=</span> <span class="vi">@mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="p">{</span> <span class="vi">@event</span><span class="p">.</span><span class="nf">reset</span><span class="p">;</span> <span class="vi">@queue</span><span class="p">.</span><span class="nf">first</span> <span class="p">}</span>
        <span class="k">break</span> <span class="k">unless</span> <span class="n">task</span>

        <span class="k">if</span> <span class="n">task</span><span class="p">.</span><span class="nf">schedule_time</span> <span class="o">&lt;=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span>
          <span class="c1"># Pop the first item in the queue</span>
          <span class="n">task</span> <span class="o">=</span> <span class="vi">@mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="p">{</span> <span class="vi">@queue</span><span class="p">.</span><span class="nf">shift</span> <span class="p">}</span>
          <span class="n">task</span><span class="p">.</span><span class="nf">run</span>
        <span class="k">else</span>
          <span class="n">timeout</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span><span class="p">.</span><span class="nf">schedule_time</span> <span class="o">-</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">,</span> <span class="mi">60</span><span class="p">].</span><span class="nf">min</span>
          <span class="vi">@event</span><span class="p">.</span><span class="nf">wait</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>There‚Äôs a lot going on here, but here are the landmarks:</p>

<ul>
  <li>In this TimerSet, <code>@queue</code> is an <code>Array</code> that we explicitly call <code>sort!</code> on so that the soonest task is always first in the array. In the Concurrent Ruby implementation, that‚Äôs done more elegantly with a <code>Concurrent::Collection::NonConcurrentPriorityQueue</code>. The <code>@mutex</code> is used to make sure that adding/sorting/peeking/popping operations on the queue are synchronized and safe across threads.</li>
  <li>The magic happens in <code>#process_tasks</code>, which creates a new thread and starts up a loop. It loops over the first task in the queue (the soonest):
    <ul>
      <li>If there is no task, it breaks the loop and exits the thread.</li>
      <li>If there is a task, it checks whether it‚Äôs time to run, and if so, runs it. If it‚Äôs not time yet, it uses the <code>Event#wait</code> until it <em>is</em> time to run, or 60 seconds, whichever is sooner. That 60 seconds is a magic number in the real implementation, and I assume that‚Äôs to reduce clock drift. Remember,  <code>Event#wait</code> is signalable, so if a new task is added, the loop will be immediately restarted and the delay recalculated.</li>
      <li>In real Concurrent Ruby, <code>task.run</code> is posted to a separate thread pool where it won‚Äôt block or slow down the loop.</li>
    </ul>
  </li>
  <li>The <code>Event#set</code> is called inside of <code>#add_task</code> which inserts new tasks into the queue. The <code>process_tasks</code> background thread is only created <em>the first time</em> a task is added to the queue after the queue has been emptied. This minimizes the number of active threads.</li>
  <li>The <code>Event#reset</code> is called when the queue is first peeked in <code>process_tasks</code>. There‚Äôs a lot of subtle race conditions being guarded against in a TimerSet. Calling reset unsets the event at the top of the loop to allow the Event to be set again before the <code>Event#wait</code></li>
</ul>

<p>And finally, we can put all of the pieces together to fulfill our use case of scheduled tasks:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">GLOBAL_TIMER_SET</span> <span class="o">=</span> <span class="no">TimerSet</span><span class="p">.</span><span class="nf">new</span>

<span class="no">ScheduledTask</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"This is the first task"</span> <span class="p">}</span>
<span class="no">ScheduledTask</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"This is the third task"</span> <span class="p">}</span>
<span class="no">ScheduledTask</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">"This is the second task"</span> <span class="p">}</span>

<span class="nb">sleep</span> <span class="mi">6</span>
<span class="no">GLOBAL_TIMER_SET</span><span class="p">.</span><span class="nf">shutdown</span>

<span class="c1">#=&gt; This is the first task</span>
<span class="c1">#=&gt; This is the second task</span>
<span class="c1">#=&gt; This is the third task</span>
</code></pre></div></div>

<h3 id="thats-it">That‚Äôs it!</h3>

<p>The TimerSet is a really neat object that‚Äôs powered by an Event, which is itself powered by a ConditionVariable. There‚Äôs a lot of fun thread-based signaling happening here!</p>

<p>While writing my post, I came across a 2014 post from Job Vranish entitled <a href="https://spin.atomicobject.com/2014/07/07/ruby-queue-pop-timeout/">‚ÄúRuby Queue Pop with Timeout‚Äù</a>, which builds something very similar looking using the same primitives. In the comments, Mike Perham linked to <a href="https://github.com/mperham/connection_pool/blob/f83b6304c0e5936b1b286b26a73f3febda051c9b/lib/connection_pool/timed_stack.rb">Connection Pool‚Äôs TimedStack</a> which also looks similar. Again <strong>please use a real library like Concurrent Ruby or Connection Pool.</strong> This was just for explanatory purposes üëç</p>

  </div>
</article>


<div class="card my-4">
  <div class="card-body">
    Discuss this with me on <a href="https://twitter.com/bensheldon"><i class="bi bi-twitter"></i> Twitter</a>
    or suggest a
    <a href="https://github.com/bensheldon/island94.org/blob/main/_posts/2023-05-31-rebuilding-concurrent-ruby-scheduledtask-event-and-timerset.md"><i class="bi bi-github"></i>
      change</a>.
  </div>
    <hr>
    <div class="card-body">
      <h5>Related Posts</h5>
      <ul>
          <li><a href="/2024/07/introducing-goodjob-v4">Introducing GoodJob v4</a></li>
          <li><a href="/2024/01/replacing-devise-with-rails-has_secure_password-and-friends">Replacing Devise with Rails `has_secure_password` and friends</a></li>
          <li><a href="/2024/01/the-answer-is-in-your-heap-debugging-big-rails-memory">The answer is in your heap: debugging a big memory increase in Ruby on Rails</a></li>
          <li><a href="/2023/12/solid-queue-first-impressions">Solid Queue first impressions: Nice!</a></li>
          <li><a href="/2023/10/reflections-on-good-job-for-solid-queue">Reflections on GoodJob for Solid Queue</a></li>
      </ul>
  </div>
</div>

  </div>

</body>
</html>
